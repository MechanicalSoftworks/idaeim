/*	misc

Copyright (C) 2013-2014 Bradford Castalia, idaeim studio.

This file is part of the idaeim libraries.

The idaeim libraries are free software; you can redistribute them and/or
modify them under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

The idaeim libraries are distributed in the hope that they will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.

CVS ID: misc.hh,v 1.13 2014/03/14 00:33:59 castalia Exp
*******************************************************************************/

#ifndef IDAEIM_MISC_HH
#define IDAEIM_MISC_HH


//	Forward references.
class QSize;


namespace idaeim
{
/*==============================================================================
	Constants
*/
/**	Value of an invalid datum.

	<b>WARNING</b>: The invalid value is the special quiet NaN value that
	can be assigned but not be meaningfully compared with other values,
	including itself. Use the {@link is_invalid(double)} function to test
	for the special invalid value.

	Note: The invalid value always produces an invalid value in math
	operations.

*/
extern const double INVALID_VALUE;

/*==============================================================================
	Utilities
*/
/**	Test if a value is the special {@link #INVALID_VALUE}.

	This function tests (using the qIsNaN function) that the value has
	the quiet NaN (not a number) bits set.

	<b>N.B.</b>: The INVALID_VALUE is generated by the qQNaN function
	which returns a bit pattern different than the
	std::numeric_limits<double>::quiet_NaN function, though both values
	have the quiet NaN bits set and so both test true by this function.

	@param	value	The value to be tested.
	@return	true if the value has the quiet NaN bits set;false otherwise.
		The special INVALID_VALUE is such a value.
*/
bool is_invalid (double value);

/**	Get the number of digits that would be used for the decimal
	representation of a value.

	@param	value	An unsigned long long integer value.
	@return	The number of digits that would be used for the decimal
		representation of the value.
*/
int decimal_digits (unsigned long long value);

/**	Get the number of digits that would be used for the hexadecimal
	representation of a value.

	@param	value	An unsigned long long integer value.
	@return	The number of digits that would be used for the hexadecimal
		representation of the value.
*/
int hex_digits (unsigned long long value);

/**	Get the number of bytes required to hold a specified number of bits.

	@param	bits	Number of bits.
	@return	The number of bytes required to hold the bits.
*/
inline unsigned int bytes_for_bits (unsigned int bits)
	{return (bits >> 3) + ((bits % 8) ? 1 : 0);}

/**	Get a bit mask value for the specified number of bits.

	@param	bits	The number of bits of precision in the mask.
	@param	lsb		The first, least significant, bit that will be set.
	@return	A bit mask value in which the specified number of bits are
		set starting with the specified least significant bit. There may
		be excess high order bits that will not fit in the value. If the
		number of bits is zero the value will be zero. 
*/
unsigned long long bits_mask (unsigned int bits, unsigned int lsb = 0);

/**	Swap groups of data bytes.

	The byte groups are swapped in place. The first byte of each group
	is swapped with the last byte in the group, the second byte is
	swapped with the next-to-last byte in the group, etc. until all
	bytes within the group have been reorderd. All byte groups are
	swapped in the same way.

	<b>N.B.</b>: The size of the byte groups is expected to be even.
	Nevertheless, if it is odd the swapping will still be done around
	the central byte which does not move.

	@param	groups	The number of groups to be reordered. If this is
		zero nothing is done.
	@param	size	The number of bytes per group. If this is less than
		two nothing is done.
	@param	data	A pointer to the first byte of the first group to
		have its bytes swapped. If NULL nothing is done.
	@return	A pointer to the end of the data; i.e. the byte after the
		last byte of the last group. If data is NULL this will be NULL.
		If groups is zero this will be the unchanged data address. If
		size is less than 2 - no swapping is done - the appropriate
		end-of-data  pointer is still returned.
*/
unsigned char* swap_bytes
	(unsigned long long groups, unsigned int size, unsigned char* data);

/**	Get	a pixel sample value from a color value.

	A color value is a 4 byte (QRgb) integer in MSB data order. The
	most significant byte is the alpha channel value, the next byte
	is the red value, then the green value, and the least significant
	byte is the blue value.

	@param	color_value	A QRgb color value.
	@param	band	The pixel sample band value to get. Band 0 is
		the red band, band 1 is the green band, band 2 is the
		blue band. The alpha channel value can be accessed using
		band -1.
	@return	An unsigned 8-bit integer value for the selected band.
*/
inline unsigned char sample_value (unsigned int color_value, int band)
	{return (unsigned char)((color_value >> ((3 - ++band) << 3)) & 0xFF);}


/**	Whether the host system native multi-byte data is MSB ordered.

	@see MSB_host()
*/
extern const bool HOST_IS_MSB;

/**	Test if the host system uses MSB ordered data.

	An application working with multi-byte values may need to match
	the data byte order to the native data order of the host.

	For MSB data the first byte of a multi-byte data value has the
	most significant part of the value. For LSB data the first byte
	has the least significant part of the value.

	<b>N.B.</b>: The HOST_IS_MSB global flag can be used directly
	without having to call this function.

	@return	true if the host system uses MSB ordered data; false if
		the host system uses LSB ordered data.
*/
bool MSB_host ();

/**	Get the scaling factor that will fit a size to an area.

	The scaling factor is calculated for the given size that will
	maximally fill, but not exceed, the given area while maintaining the
	aspect ratio of the specified size.

	@param	size	A QSize to be fitted to the area.
	@param	area	The area within which to fit the size.
	@return	The scaling factor that when applied to the specified size
		will produce a new size that will be as large as possible within
		the specified area.
*/
double scale_to_area (const QSize& size, unsigned long long area);

}		//	namespace idaeim
#endif	//	IDAEIM_MISC_HH
